/* tslint:disable */
/* eslint-disable */
/**
 * Swap API
 * The heart and soul of Jupiter lies in the Quote and Swap API.  ### API Rate Limit Since 1 December 2024, we have updated our API structure. Please refer to [Developer Docs](https://dev.jup.ag/docs/) for further details on usage and rate limits.  ### API Usage - API Wrapper Typescript [@jup-ag/api](https://github.com/jup-ag/jupiter-quote-api-node)  ### Data Types To Note - Public keys are base58 encoded strings - Raw data such as Vec<u8\\> are base64 encoded strings 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { QuoteResponse } from './QuoteResponse';
import {
    QuoteResponseFromJSON,
    QuoteResponseFromJSONTyped,
    QuoteResponseToJSON,
} from './QuoteResponse';
import type { SwapRequestPrioritizationFeeLamports } from './SwapRequestPrioritizationFeeLamports';
import {
    SwapRequestPrioritizationFeeLamportsFromJSON,
    SwapRequestPrioritizationFeeLamportsFromJSONTyped,
    SwapRequestPrioritizationFeeLamportsToJSON,
} from './SwapRequestPrioritizationFeeLamports';

/**
 * 
 * @export
 * @interface SwapRequest
 */
export interface SwapRequest {
    /**
     * The user public key.
     * @type {string}
     * @memberof SwapRequest
     */
    userPublicKey: string;
    /**
     * Allow a custom payer to pay for the transaction.
     * @type {string}
     * @memberof SwapRequest
     */
    payer?: string;
    /**
     * - To automatically wrap/unwrap SOL in the transaction
     * - If false, it will use wSOL token account
     * - Parameter will be ignored if `destinationTokenAccount` is set because the `destinationTokenAccount` may belong to a different user that we have no authority to close
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    wrapAndUnwrapSol?: boolean;
    /**
     * - The default is determined dynamically by the routing engine, allowing us to optimize for compute units, etc
     * - This enables the usage of shared program accounts, this is essential as complex routing will require multiple intermediate token accounts which the user might not have
     * - If true, you do not need to handle the creation of intermediate token accounts for the user
     * - Do note, shared accounts route will fail on some new AMMs (low liquidity token)
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    useSharedAccounts?: boolean;
    /**
     * - An token account that will be used to collect fees
     * - The mint of the token account **can only be either the input or output mint of the swap**
     * - You no longer are required to use the Referral Program
     * - See [Add Fees](/docs/swap-api/add-fees-to-swap) guide for more details
     * 
     * @type {string}
     * @memberof SwapRequest
     */
    feeAccount?: string;
    /**
     * - Specify any public key that belongs to you to track the transactions
     * - Useful for integrators to get all the swap transactions from this public key
     * - Query the data using a block explorer like Solscan/SolanaFM or query like Dune/Flipside
     * 
     * @type {string}
     * @memberof SwapRequest
     */
    trackingAccount?: string;
    /**
     * 
     * @type {SwapRequestPrioritizationFeeLamports}
     * @memberof SwapRequest
     */
    prioritizationFeeLamports?: SwapRequestPrioritizationFeeLamports;
    /**
     * - Builds a legacy transaction rather than the default versioned transaction
     * - Used together with `asLegacyTransaction` in `/quote`, otherwise the transaction might be too large
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    asLegacyTransaction?: boolean;
    /**
     * - Public key of a token account that will be used to receive the token out of the swap
     * - If not provided, the signer's token account will be used
     * - If provided, we assume that the token account is already initialized
     * 
     * @type {string}
     * @memberof SwapRequest
     */
    destinationTokenAccount?: string;
    /**
     * - When enabled, it will do a swap simulation to get the compute unit used and set it in ComputeBudget's compute unit limit
     * - This incurs one extra RPC call to simulate this
     * - We recommend to enable this to estimate compute unit correctly and reduce priority fees needed or have higher chance to be included in a block
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    dynamicComputeUnitLimit?: boolean;
    /**
     * - When enabled, it will not do any additional RPC calls to check on required accounts
     * - Enable it only when you already setup all the accounts needed for the trasaction, like wrapping or unwrapping sol, or destination account is already created
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    skipUserAccountsRpcCalls?: boolean;
    /**
     * - When enabled, it estimates slippage and apply it in the swap transaction directly, overwriting the `slippageBps` parameter in the quote response.
     * - Used together with `dynamicSlippage` in `/quote`, otherwise the slippage used will be the one in the `/quote`'s `slippageBps`
     * - [See notes for more information](/docs/swap-api/send-swap-transaction#how-jupiter-estimates-slippage)
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    dynamicSlippage?: boolean;
    /**
     * - To use an exact compute unit price to calculate priority fee
     * - `computeUnitLimit (1400000) * computeUnitPriceMicroLamports`
     * - We recommend using `prioritizationFeeLamports` and `dynamicComputeUnitLimit` instead of passing in your own compute unit price
     * 
     * @type {number}
     * @memberof SwapRequest
     */
    computeUnitPriceMicroLamports?: number;
    /**
     * - Pass in the number of slots we want the transaction to be valid for
     * - Example: If you pass in 10 slots, the transaction will be valid for ~400ms * 10 = approximately 4 seconds before it expires
     * 
     * @type {number}
     * @memberof SwapRequest
     */
    blockhashSlotsToExpiry?: number;
    /**
     * 
     * @type {QuoteResponse}
     * @memberof SwapRequest
     */
    quoteResponse: QuoteResponse;
}

/**
 * Check if a given object implements the SwapRequest interface.
 */
export function instanceOfSwapRequest(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "userPublicKey" in value;
    isInstance = isInstance && "quoteResponse" in value;

    return isInstance;
}

export function SwapRequestFromJSON(json: any): SwapRequest {
    return SwapRequestFromJSONTyped(json, false);
}

export function SwapRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): SwapRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'userPublicKey': json['userPublicKey'],
        'payer': !exists(json, 'payer') ? undefined : json['payer'],
        'wrapAndUnwrapSol': !exists(json, 'wrapAndUnwrapSol') ? undefined : json['wrapAndUnwrapSol'],
        'useSharedAccounts': !exists(json, 'useSharedAccounts') ? undefined : json['useSharedAccounts'],
        'feeAccount': !exists(json, 'feeAccount') ? undefined : json['feeAccount'],
        'trackingAccount': !exists(json, 'trackingAccount') ? undefined : json['trackingAccount'],
        'prioritizationFeeLamports': !exists(json, 'prioritizationFeeLamports') ? undefined : SwapRequestPrioritizationFeeLamportsFromJSON(json['prioritizationFeeLamports']),
        'asLegacyTransaction': !exists(json, 'asLegacyTransaction') ? undefined : json['asLegacyTransaction'],
        'destinationTokenAccount': !exists(json, 'destinationTokenAccount') ? undefined : json['destinationTokenAccount'],
        'dynamicComputeUnitLimit': !exists(json, 'dynamicComputeUnitLimit') ? undefined : json['dynamicComputeUnitLimit'],
        'skipUserAccountsRpcCalls': !exists(json, 'skipUserAccountsRpcCalls') ? undefined : json['skipUserAccountsRpcCalls'],
        'dynamicSlippage': !exists(json, 'dynamicSlippage') ? undefined : json['dynamicSlippage'],
        'computeUnitPriceMicroLamports': !exists(json, 'computeUnitPriceMicroLamports') ? undefined : json['computeUnitPriceMicroLamports'],
        'blockhashSlotsToExpiry': !exists(json, 'blockhashSlotsToExpiry') ? undefined : json['blockhashSlotsToExpiry'],
        'quoteResponse': QuoteResponseFromJSON(json['quoteResponse']),
    };
}

export function SwapRequestToJSON(value?: SwapRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'userPublicKey': value.userPublicKey,
        'payer': value.payer,
        'wrapAndUnwrapSol': value.wrapAndUnwrapSol,
        'useSharedAccounts': value.useSharedAccounts,
        'feeAccount': value.feeAccount,
        'trackingAccount': value.trackingAccount,
        'prioritizationFeeLamports': SwapRequestPrioritizationFeeLamportsToJSON(value.prioritizationFeeLamports),
        'asLegacyTransaction': value.asLegacyTransaction,
        'destinationTokenAccount': value.destinationTokenAccount,
        'dynamicComputeUnitLimit': value.dynamicComputeUnitLimit,
        'skipUserAccountsRpcCalls': value.skipUserAccountsRpcCalls,
        'dynamicSlippage': value.dynamicSlippage,
        'computeUnitPriceMicroLamports': value.computeUnitPriceMicroLamports,
        'blockhashSlotsToExpiry': value.blockhashSlotsToExpiry,
        'quoteResponse': QuoteResponseToJSON(value.quoteResponse),
    };
}

